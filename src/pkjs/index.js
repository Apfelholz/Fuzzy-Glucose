var VERSION = "1.3.0";
var Clay = require('pebble-clay');
var clayConfig = require('./config.json');
var clay = new Clay(clayConfig, null, { autoHandleEvents: false });
var API = {
  BASE_URL: "https://api-eu.libreview.io",
  PRODUCT: "llu.android",
  VERSION: "4.16.0",
  REGION: "eu"
};
var testCredentials;
try {
  testCredentials = require('./credentials.json');
} catch (e) {
  testCredentials = {};
}

var isReady = false;
var callbacks = [];
var fetchInFlight = null;

// Message keys generated by Pebble SDK (see package.json messageKeys)
var KEYS = require('message_keys');

function onReady(callback) {
  if (isReady) {
    callback();
    return;
  }
  callbacks.push(callback);
}

function logError(err) {
  console.log('AppMessage error: ' + JSON.stringify(err));
}

// Store latest glucose data
var glucoseData = {
  value: 0,
  trend: -1,
  timestamp: 0
};

// Minimal SHA-256 for environments without subtle crypto
function simpleSha256(str) {
  function rightRotate(value, amount) {
    return (value >>> amount) | (value << (32 - amount));
  }
  var mathPow = Math.pow;
  var maxWord = mathPow(2, 32);
  var lengthProperty = "length";
  var i, j;
  var result = "";
  var words = [];
  var strBitLength = str[lengthProperty] * 8;
  var hash = simpleSha256.h = simpleSha256.h || [];
  var k = simpleSha256.k = simpleSha256.k || [];
  var primeCounter = k[lengthProperty];

  var isComposite = {};
  for (var candidate = 2; primeCounter < 64; candidate++) {
    if (!isComposite[candidate]) {
      for (i = 0; i < 313; i += candidate) {
        isComposite[i] = candidate;
      }
      hash[primeCounter] = (mathPow(candidate, 0.5) * maxWord) | 0;
      k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0;
    }
  }

  str += "\u0080";
  while ((str[lengthProperty] % 64) - 56) {
    str += "\u0000";
  }
  for (i = 0; i < str[lengthProperty]; i++) {
    j = str.charCodeAt(i);
    if (j >> 8) {
      return null;
    }
    words[i >> 2] |= j << ((3 - i) % 4) * 8;
  }
  words[words[lengthProperty]] = (strBitLength / maxWord) | 0;
  words[words[lengthProperty]] = strBitLength;

  for (j = 0; j < words[lengthProperty]; ) {
    var w = words.slice(j, (j += 16));
    var oldHash = hash;
    hash = hash.slice(0, 8);

    for (i = 0; i < 64; i++) {
      var w15 = w[i - 15];
      var w2 = w[i - 2];
      var a = hash[0];
      var e = hash[4];
      var temp1 =
        hash[7] +
        (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) +
        ((e & hash[5]) ^ (~e & hash[6])) +
        k[i] +
        (w[i] =
          i < 16
            ? w[i]
            : (w[i - 16] +
               (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) +
               w[i - 7] +
               (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))) | 0);
      var temp2 =
        (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) +
        ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));

      hash = [(temp1 + temp2) | 0].concat(hash);
      hash[4] = (hash[4] + temp1) | 0;
    }

    for (i = 0; i < 8; i++) {
      hash[i] = (hash[i] + oldHash[i]) | 0;
    }
  }

  for (i = 0; i < 8; i++) {
    for (j = 3; j + 1; j--) {
      var b = (hash[i] >> (j * 8)) & 255;
      result += (b < 16 ? 0 : "") + b.toString(16);
    }
  }
  return result;
}

function sha256Hex(str) {
  if (typeof crypto !== "undefined" && crypto.subtle && crypto.subtle.digest) {
    var enc = new TextEncoder();
    return crypto.subtle.digest("SHA-256", enc.encode(str)).then(function(buf) {
      var out = "";
      var view = new DataView(buf);
      for (var i = 0; i < view.byteLength; i += 4) {
        out += ("00000000" + view.getUint32(i).toString(16)).slice(-8);
      }
      return out;
    });
  }
  return Promise.resolve(simpleSha256(str));
}

function readyCallback(event) {
  isReady = true;
  console.log("Pebble JS ready");
  while (callbacks.length > 0) {
    var callback = callbacks.shift();
    callback(event);
  }
}

function showConfiguration(event) {
  console.log('Configuration page requested (Clay)');
  Pebble.openURL(clay.generateUrl());
}

function webviewclosed(event) {
  if (!event || !event.response || event.response === 'CANCELLED') {
    console.log('Configuration cancelled or empty');
    return;
  }

  try {
    var options = clay.getSettings(event.response);
    console.log('Clay settings parsed: ' + JSON.stringify(options));
    localStorage.setItem('options', JSON.stringify(options));

    var message = {};
    message[KEYS.INVERT_KEY] = options.INVERT ? 1 : 0;
    message[KEYS.TEXT_ALIGN_KEY] = parseInt(options.TEXT_ALIGN || '0', 10);
    message[KEYS.LANGUAGE_KEY] = parseInt(options.LANGUAGE || '3', 10);

    sendSettingsToWatch(message);
  } catch (e) {
    console.log('Error parsing configuration: ' + e.message);
  }
}

function sendSettingsToWatch(message) {
  if (!isReady) {
    callbacks.push(function() { sendSettingsToWatch(message); });
    return;
  }

  Pebble.sendAppMessage(message, function() {
    console.log('Settings delivered to watch: ' + JSON.stringify(message));
  }, function(err) {
    console.log('Error sending settings: ' + JSON.stringify(err));
  });
}

function getOptions() {
  return localStorage.getItem("options") || "{}";
}

function parseOptions() {
  try {
    return JSON.parse(getOptions());
  } catch (e) {
    console.log('Error parsing stored options, using defaults');
    return {};
  }
}

function appmessage(event) {
  console.log('Received message from watch');
  var payload = event.payload;

  if (payload && payload[KEYS.KEY_REQUEST_DATA]) {
    console.log('Watch requested glucose data');
    fetchGlucoseFromLibreLinkUp().then(function() {
      sendGlucoseData();
    });
  }
}

function transmitConfiguration(settings) {
  console.log('Sending configuration: ' + JSON.stringify(settings));
  Pebble.sendAppMessage(settings, function(event) {
    console.log('Configuration delivered successfully');
  }, logError);
}

function sendGlucoseData() {
  if (glucoseData.value <= 0) {
    console.log('No glucose data to send');
    return;
  }

  var message = {};
  message[KEYS.KEY_GLUCOSE_VALUE] = glucoseData.value;
  message[KEYS.KEY_TREND_VALUE] = glucoseData.trend;
  message[KEYS.KEY_TIMESTAMP] = glucoseData.timestamp;

  console.log('Sending glucose data: ' + JSON.stringify(message));
  Pebble.sendAppMessage(message, function(event) {
    console.log('Glucose data delivered');
  }, logError);
}

function updateGlucoseData(value, trend, timestamp) {
  glucoseData.value = value || 0;
  glucoseData.trend = (typeof trend !== 'undefined') ? trend : -1;
  glucoseData.timestamp = timestamp || Math.floor(Date.now() / 1000);
  console.log('Glucose updated: ' + glucoseData.value + ' mg/dL, trend: ' + glucoseData.trend);

  onReady(function() {
    sendGlucoseData();
  });
}

Pebble.updateGlucose = updateGlucoseData;

function pickMeasurement(container) {
  if (!container) return null;
  var m = container.glucoseMeasurement || container.glucoseItem || container;
  if (m && m.measurementData && m.measurementData.length) {
    return m.measurementData[m.measurementData.length - 1];
  }
  return m;
}

// Für die LibreLinkUp-Fetch-Funktion alles mit normalen Funktionen und keine ES6 Features
// (hier würde der Fetch-Code analog umgesetzt werden, alles mit var, function, .then())

Pebble.addEventListener('ready', readyCallback);
Pebble.addEventListener('showConfiguration', showConfiguration);
Pebble.addEventListener('webviewclosed', webviewclosed);
Pebble.addEventListener('appmessage', appmessage);
